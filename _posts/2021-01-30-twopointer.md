---
title: 예제를 통한 '투 포인터' 방법의  (2003번, 1484번) (미완성)
tags: 투 포인터
key: 알고리즘
tags: 백준 2003, 1484
---

# 개요

## 투 포인터란?

어쩌면 two 'pointer' 보다 two 'iterator'라는 말이 의미에 와닿을 지도 모른다. C나 C++을 하시는 분들은 포인터라는 말을 들으면 "주소를 저장하는 변수"가 먼저 떠오르다 보니, "두 개의 포인터 변수를 사용하는 건가?" 라고 생각할 수도 있지만 여기서 말하는 것은 그게 아니다. ~~(그래서 포인터라는 변수의 네이밍 센스가 별로라고 생각함, 차라리 '주소 변수' address variable이라고 부르는게 훨씬 직관적이지 않나?)~~ 1차원 배열을 순회하는데, 두 개의 iterator를 가지고 원하는 결과를 얻는 알고리즘을 '투 포인터 알고리즘' 이라고 부른다.  

만약 정렬(sorting)을 공부했다면 우린 이미 투 포인터 알고리즘을 사용했을 지도 모른다. Quick Sort와 Merge Sort에서 left, right를 이용하여 배열을 순회하면서 정렬하는것 그것도 일종의 투 포인터라고 볼 수 있다.


# 문제풀이 (2003번)

이를 이해하기 위해 예시를 하나 들어보겠다.

<center><img src="/image/2021-01-30/2003.png"></center>

이를 투 포인터 알고리즘으로 풀어보려고 한다.  

그런데 여기서 의심해야하는 부분이 있다. 결국 우리는 i번째 수부터 j번째 수 까지의 합이 주어진 수 M이 되는 i와 j의 쌍이 몇개 있는지를 알아내야 한다. 당연히 이중 for 문을 사용하게 되면 $O(N^{2})$의 시간복잡도를 가지게 되고 시간제한이 0.5초 이므로 풀 수 없다. 즉, 최소 linear time complexity를 가지는 알고리즘을 생각해야 한다.  

## 투 포인터 알고리즘의 정당성

그렇기 때문에 투 포인터를 사용해야 한다. 이제 left, right라는 변수를 사용하여 배열을 순회하도록 하자.

### 어떤 방식으로 돌아가는지 확인하자!

<center><img src="/image/2021-01-30/tp_ex.jpeg"></center>

3 가지의 상태를 가져왔다. 우선 사진에서 첫 번째 상태는 초기 상태인데, left와 right가 모두 배열의 첫 번째 원소 $a_{1}$을 가리키고 있다.  

만약 left 부터 right 까지의 합이 주어진 $M$보다 작다면 어떤 행동을 취해야 할까? 숫자를 더 더해야 할 것이다. 더 더한다는 것을 투 포인터의 입장에서 생각하면 어떻게 될까? left와 right의 간격을 벌리면 된다. left와 right의 간격을 벌린다는 것은 어떤 의미일까? left가 감소하거나 right가 증가하는 것이 되겠다.  

그런데 left와 right가 왼쪽에서 오른쪽으로 순회한다는 사실을 생각해 보자. left가 감소한다(왼쪽으로 간다)라는 것은 이미 순회했던 원소를 다시 가리키겠다는 의미이다. 이는 무의미한 중복이 된다. 그리고 애초에 이중 반복분을 피하기 위해 투 포인터를 사용했기 때문에 '다시 돌아간다'라는 것은 시간복잡도 측면에서도 유용하지 않은 것 같다.  

그렇기 때문에 right 가 증가하여(오른쪽으로 이동) left ~ right 구간의 합을 증가시키는 것이 맞다.  

그렇다면 이번에는 left 부터 right 까지의 합이 주어진 $M$ 보다 크다면 어떤 행동을 취해야 할까? 투 포인터간의 간격을 줄여야 하고 이는 left를 오른쪽으로 이동시키는 것이 되겠다.  

### 모든 경우가 다 고려되는가?

이걸 말로 때우기가 참 어렵다. 이럴때 수식이 필요한게 아닐까? 수식을 사용하면 말로 때우기 어려운 것들을 쉽게 명료화할 수 있다.  

상황을 정리해 보자.  

$n$ 개의 수로 이루어진 수열(정수의 배열) $a_{1}, a_{2}, \cdots , a_{n-1}, a_{n}$을 생각해 보자. '위에서 언급한 투 포인터 방법을 이용하여 이 수열을 순회할 때, $$\sum_{k = left}^{right} a_{k} = M$$
을 만족하는 left, right 쌍을 모두 찾을 수 있다'는 말이 된다.  

만약 이것이 참이 아니라면 어떤 $i, j$가 존재해서 $\sum_{i}^{j} a_{k} = M$ 이지만, left, right가 순회하지 못한다는 것이다.  

그런데 right는 첫 원소부터 마지막 원소까지 전부 순회하기 때문에, j와 무조건 한번 만나는 순간이 있다. 다시말해 $right = j$인 순간이 있다.(이것에 대한 엄밀한 증명은, 연속함수로 확장한 다음, 중간값 정리를 이용하면 된다. 그러나 직관적으로 참이므로 패스)  

그런데 $(left, right) = (i, j)$인 경우가 없다는것은 무슨 소릴까?  

생각해보면 두 가지 경우만이 가능함을 할 수 있다.  

1. $right = j$ 일 때, $left < i$ 인 경우  
    $i$ 부터 $j$까지의 합이 $M$이므로 left 부터 right 까지의 합은 $M$ 초과가 되어야 한다. 그럼 구간을 줄여야 한다. 언제까지 구간을 줄여야 할까? 바로 $left = i$ 일때까지 줄여야 한다.

2. $right = j$ 일 때, $left > i$ 인 경우  
    $i$부터 $j$까지의 합이 $M$이므로 left 부터 right 까지의 합은 $M$ 미만이 되어야 한다. 그렇기 때문에 left가 $i$ 미만일 때도 있었을 것이다. 그때 $right = j$가 아닐수도 있다. 만약에 그 때 $right = j$ 였다면 구간합을 줄이기 위해 left를 증가시키게 되고 결국 $i$에 도달하게 될 것이다.  
    만약 $right \neq j$ 였다면 $right < j$이어야만 한다(전제에 의해).  

    **(여기에서의 중간값 정리는 모두 연속적 확장을 이용하여 보입니다).**  

    만약 이 때, left 부터 right까지의 구간합이 $M$ 보다 작아서 구간을 늘리는 경우라고 생각해 보자, 계속 늘리는데도 구간합이 작을 수는 없는데 왜냐면 $right = j$인 경우까지 늘린다면 결국에는 $M$보다 커지기 때문이다. 그러므로 중간값의 정리에 의해 $right = k < j$인 $k$가 존재해서 $left < i$부터 right까지의 합이 $M$이 된다. 구간합이 $M$이 되었기 때문에 left를 증가시켜야만 하는데, $left = i$인 순간까지는 아무리 못해도 증가시킬 수 있다.  

그러므로 투 포인터 방법으로 모든 경우를 순회할 수 있음이 증명되었다.  

## 소스코드
```cpp
#include <iostream>

using namespace std;

enum
{
    MAX_LENGTH = 10002
};

size_t nums[MAX_LENGTH];

int main(void)
{
    size_t N, M, sum = 0, left = 0, right = 0, cnt = 0;
    cin >> N >> M;
    for(size_t i = 1 ; i <= N ; i++)
    {
        cin >> nums[i];
    }
    while(right <= N || left <= N)
    {
        // 구간에 포함되는 수의 합이 M이 되도록 해야 한다.
        // sum이 M인 순간을 찾아야 한다.
        if(sum > M)
        {
            sum -= nums[++left];
        }
        else if(sum < M)
        {
            sum += nums[++right];
        }
        else
        {
            cnt++;
            sum -= nums[++left];
        }

    }
    cout << cnt;
    return 0;
}
```
여기서는 left, right를 0-base인 투 포인터로 사용하였기 때문에, 배열의 크기를 최대치 보다 크게 잡았다.  

# 문제풀이 (1484번)


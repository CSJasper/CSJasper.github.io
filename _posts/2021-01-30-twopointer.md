---
title: 예제를 통한 '투 포인터' 방법의  (2003번, 1484번) (미완성)
tags: 투 포인터
key: 알고리즘
tags: 백준 2003, 1484
---

# 개요

## 투 포인터란?

어쩌면 two 'pointer' 보다 two 'iterator'라는 말이 의미에 와닿을 지도 모른다. C나 C++을 하시는 분들은 포인터라는 말을 들으면 "주소를 저장하는 변수"가 먼저 떠오르다 보니, "두 개의 포인터 변수를 사용하는 건가?" 라고 생각할 수도 있지만 여기서 말하는 것은 그게 아니다. ~~(그래서 포인터라는 변수의 네이밍 센스가 별로라고 생각함, 차라리 '주소 변수' address variable이라고 부르는게 훨씬 직관적이지 않나?)~~ 1차원 배열을 순회하는데, 두 개의 iterator를 가지고 원하는 결과를 얻는 알고리즘을 '투 포인터 알고리즘' 이라고 부른다.  

만약 정렬(sorting)을 공부했다면 우린 이미 투 포인터 알고리즘을 사용했을 지도 모른다. Quick Sort와 Merge Sort에서 left, right를 이용하여 배열을 순회하면서 정렬하는것 그것도 일종의 투 포인터라고 볼 수 있다.


# 문제풀이

이를 이해하기 위해 예시를 하나 들어보겠다.

<center><img src="/image/2021-01-30/2003.png"></center>

이를 투 포인터 알고리즘으로 풀어보려고 한다.  

그런데 여기서 의심해야하는 부분이 있다. 결국 우리는 i번째 수부터 j번째 수 까지의 합이 주어진 수 M이 되는 i와 j의 쌍이 몇개 있는지를 알아내야 한다. 당연히 이중 for 문을 사용하게 되면 $O(N^{2})$의 시간복잡도를 가지게 되고 시간제한이 0.5초 이므로 풀 수 없다. 즉, 최소 linear time complexity를 가지는 알고리즘을 생각해야 한다.  

## 투 포인터 알고리즘의 정당성

그렇기 때문에 투 포인터를 사용해야 한다. 이제 left, right라는 변수를 사용하여 배열을 순회하도록 하자.

### 어떤 방식으로 돌아가는지 확인하자!

<center><img src="/image/2021-01-30/tp_ex.jpeg"></center>

3 가지의 상태를 가져왔다. 우선 사진에서 첫 번째 상태는 초기 상태인데, left와 right가 모두 배열의 첫 번째 원소 $a_{1}$을 가리키고 있다.  

만약 left 부터 right 까지의 합이 주어진 $M$보다 작다면 어떤 행동을 취해야 할까? 숫자를 더 더해야 할 것이다. 더 더한다는 것을 투 포인터의 입장에서 생각하면 어떻게 될까? left와 right의 간격을 벌리면 된다. left와 right의 간격을 벌린다는 것은 어떤 의미일까? left가 감소하거나 right가 증가하는 것이 되겠다.  

그런데 left와 right가 왼쪽에서 오른쪽으로 순회한다는 사실을 생각해 보자. left가 감소한다(왼쪽으로 간다)라는 것은 이미 순회했던 원소를 다시 가리키겠다는 의미이다. 이는 무의미한 중복이 된다. 그리고 애초에 이중 반복분을 피하기 위해 투 포인터를 사용했기 때문에 '다시 돌아간다'라는 것은 시간복잡도 측면에서도 유용하지 않은 것 같다.  

그렇기 때문에 right 가 증가하여(오른쪽으로 이동) left ~ right 구간의 합을 증가시키는 것이 맞다.  

그렇다면 이번에는 left 부터 right 까지의 합이 주어진 $M$ 보다 크다면 어떤 행동을 취해야 할까? 투 포인터간의 간격을 줄여야 하고 이는 left를 오른쪽으로 이동시키는 것이 되겠다.  

### 모든 경우가 다 고려되는가?

이걸 말로 때우기가 참 어렵다. 이럴때 수식이 필요한게 아닐까? 수식을 사용하면 말로 때우기 어려운 것들을 쉽게 명료화할 수 있다.  

상황을 정리해 보자.  

$n$ 개의 수로 이루어진 수열(정수의 배열) $a_{1}, a_{2}, \cdots , a_{n-1}, a_{n}$을 생각해 보자. 위에서 언급한 투 포인터 방법을 이용하여 이 수열을 순회할 때, $$\sum_{k = left}^{right} a_{k} = M$$
---
title: 백준 20500 (Ezreal 여눈부터 가네 ㅈㅈ) 풀이 (미완성)
tags: 백준 문제
key: 백준PS
tags: 백준PS-20500
---

<center><img src="/image/20500/ezreal.png"></center>


# 문제 읽기

문제 자체는 간단하다. 입력받은 $N$에 대하여, 1, 5로 만 구성된 $N$자리 양의 정수 중에서 15의 배수가 몇 개인지 찾는 문제이다.  

아주 naive 하게 문제를 풀어본다면, 1, 5로 이루어진 $N$ 자리 정수를 다 확인하면서 15의 배수인지 찾는 방법이다.  

그러나 이 경우에 총 $2^{N}$가지의 경우에 대해서 15의 배수인지 확인해야 하므로 $O(2^{N})$의 시간 복잡도를 가지게 되는데, $N$의 최댓값이 1515이므로 $2^{1515}$ 번의 비교를 해야한다.  

즉, 이러한 방법으로는 풀 수 없다. ~~(할수야 있겠지, 시간만 많다면)~~

# 이해하기  

## 조건 세분화 하기

우선 15의 배수라는것은 5의 배수이면서 3의 배수라는 것이다.   

여기서 어떤 것이 더 판별하기 쉬울까? 3의 배수는 10의 거듭제곱이 3으로 나눈 나머지가 1이 된다는 성질을 이용하여 3의 배수인지 판정하지만, 5의 배수인 경우는 그냥 마지막 자리만 확인하면 된다.  

그러므로 마지막 자리가 0 또는 5인 숫자들 중에서 3의 배수인 것을 찾는게 더 나은 방법으로 보인다.  

## 예시를 들어보자!

$N = 3$ 인 경우를 살펴볼까? 115는 안된다. 왜냐면 3의 배수가 아니니까! 반면 555는 된다. 왜냐면 3의 배수니까! 이것을 3의 배수의 관점에서 본다면 1은 나머지가 1, 5는 나머지가 2인 수이다. 115는 나머지의 관점에서 보면 2 + 2 = 4 = 1이 되서 안되는 거고, 155는 5 + 5 + 5 = 0이어서 되는 거다.  

결국 관찰하는 숫자는 3의 배수의 관점에서 보면 나머지가 1인 수와 2 인수의 조합이다.  

만약에 숫자가 5로 끝난다 하고 1의 개수를 $m$개 5의 개수를 $n$개라고 한다면 $3 |(m + n)$을 만족해야 한다는 의미다.(3 divides $m + n$)  

숫자가 0으로 끝나도 마찬가지이다. 다만 숫자를 이루는 수의 개수에서 차이가 있을 뿐이다.  

위에서 정의한 $m, n$의 정의를 재활용하여 표기한다면,  

1. 마지막 수가 0으로 끝나는 경우, $N = m + n + 1$이고 $3\vert(m + n)$ 이다.  

2. 마지막 수가 5로 끝나는 경우, $N = m + n$이고 $3\vert(m + n)$ 이다.

를 만족시키는 $m, n$의 개수가 정하면 끝인건가? 그건 아니다, 왜냐면 수의 배열이 다르면 다른 숫자이기 때문이다.  

근데 생각해보면 애초에 끝자리가 0일수가 없잖아??? 허무하다...

### Feedback

위의 생각은 틀린 생각은 아니지만 문제를 푼다는 관점에서 볼때, 도움이 되는 생각은 아닌것 같으니 잠시 접어두고 다른 방향의 생각을 하는것이 좋을 것 같다.

## 부분 문제 구조를 찾을 수 있나?

잘 못찾겠으니 작은 숫자를 잡아서 예시를 들어보자.  
$N = 3$ 일때의 5의 배수는  
> 115, 155, 515, 555  

밖에 없다. 이는 마지막 자리를 5로 고정시켰기 때문인데, 일단 이러한 숫자의 개수는 $2^{N-1}$개 이다.  

여기서 3의 배수인 것을 찾으면

> 555

로 유일하다.

그 다음 $N = 4$ 일때의 개수는 8개이므로 충분히 나열해 볼 만하다.

> 1115, 1155, 1515, 5115, 1555, 5155, 5515, 5555

이다.  

여기서 3의 배수인 것을 찾으면  

> 1155, 1515, 5115

이다. 

일단 이것만 봐서는 규칙이 없는 것 같아 보인다.  

그러므로 $N = 3$일 때는 왜 555 하나만 나왔는지 구조를 이해할 필요가 있다. 물론 $N = 4$일 때도 마찬가지다.  

그런데 부분 문제에 초점을 두기로 했기 때문에 이전 결과로부터, 즉 "$N \leq 2$일 때의 결과를 이용할 수 있나?" 를 생각해 보자.  

555는 55에 5를 왼쪽에 하나 추가한 수라고 할 수 있는데, 55는 3의 배수가 아니다. 그런데 3으로 나눌때, 나머지가 1이다. 이런 숫자는 나머지가 2인 수가 추가된다면 3의 배수가 된다. 즉, $N = 2$일때 5의 배수이면서 3으로 나눴을때 나머지가 2인 수의 개수를 알면, $N = 3$일 때의 15의 배수의 개수를 구할 수 있다!  

$N = 4$ 일때도 살펴볼까?  

1155를 보면 155는 3의 배수가 아니다. 이것은 3으로 나누었을 때, 나머지가 2이다. 그러니까 1을 추가하여 3의 배수로 만든거다.  

### Feedback

여기서 얻을 수 있는 교훈이 뭘까? 3으로 나누었을 때의 나머지가 중요하다는 것 아닐까?  

* 이전의 수가 3의 배수라면 1 또는 5 숫자 한개를 추가해서 3의 배수로 다음 수를 만들 수는 없다. 최소한 2개의 수를 추가해야 한다.  

* 이전의 수가 3으로 나눴을 때 나머지가 1인 수라면 숫자 5 한개를 추가하여 그 다음 숫자를 3의 배수로 만들 수 있다. 즉 최소 1개의 수를 추가해야 한다.  

* 이전의 수가 3으로 나눴을 때 나머지가 2인 수라면 숫자 1 한개를 추가하여 그 다음 숫자를 3의 배수로 만들 수 있다. 즉 최소 1개의 수를 추가해야 한다.  

여기서 또 다른 교훈을 얻었다. 3의 배수인 경우에는 숫자를 최소 2개 더 추가해야 한다. 즉, 이전의 수와 그 전 전의 수를 확인해야 한다는 것이다.  

## 중간 점검

우리는 그러면 어떤 결론에 도달할 수 있는가? 만약 $n$자리 수를 본다고 한다면 $n-1, n-2$자리의 5로 끝나는 숫자 중에서 3으로 나눌때 나머지가 0, 1, 2인 숫자의 개수를 알고 있다면 이를 통해 $n$자리 수중 15의 배수의 개수를 구할 수 있다.  

그리고 이는 부분 문제 구조를 이루어야 하므로, 한가지 더 확인 해야 할 것이 있다. $n-1, n-2$자리의 5로 끝나는 숫자 중에서 3으로 나눌 때 나머지가 0, 1, 2인 수의 개수를 알고 있다면, 이를 이용하여 $n$자리의 5로 끝나는 숫자 중에서 3으로 나눌때의 나머지가 0, 1, 2인 수의 개수를 알 수 있을까?  

우선 표기의 효율성을 위해 modulo_num[$n$][$k$]를  
> modulo_num[$n$][$k$] := 1 또는 5로만 만든 $n$자리의 5로 끝나는 숫자 중에서 3으로 나눌 때 나머지가 $k$인 수  

라 하자.

1. modulo_num[$n$][0]  

$n$자리의 5로 끝나는 숫자 중에서 3으로 나눌 때 나머지가 0인 수는 위의 관찰을 이용하면, $n-2$자리의 수에서 소급하여 보면  

(modulo_num[$n-2$][0] + 2) + (modulo_num[$n-2$][1] + 1) + (modulo_num[$n-2$][2] + 1)  

이는 2개의 숫자를 추가하여 결과적으로 나머지를 0으로 만들어야 하기 때문이다. 모든 경우의 수는 11, 15, 51, 55의 경우가 있는데, 11의 경우 나머지가 2가 추가되는 효과, (15, 51)의 경우 나머지가 0이 추가되는 효과, 55의 경우 나머지가 2가 추가되는 효과를 가지고 있다.  

$n-1$자리의 수에서 소급해 보자. 같은 원리로  

(modulo_num[$n-1$][1] + 1) + (modulo_num[$n-1$][2] + 1)  

이다.  

modulo_num[$n-1$][0] 일때의 경우를 구하지 않았는데, 왜 그런지 궁금하다면 위의 관찰을 다시 읽어봤으면 한다. 이미 우리가 관찰한 내용이다.  

2. modulo_num[$n$][1]  

여기까지만 와도 각이 보인다. 그냥 위의 했던 생각 그대로 아래에서도 적용하면 된다.

$n-2$ 자리의 수에서 소급하여 보자.  

(modulo_num[$n-2$][0] + 1) + (modulo_num[$n-2$][1] + 2) + (modulo_num[$n-2$][2] + 1)

$n-1$ 자리의 수에서 소급하여 보자.  

(modulo_num[$n-1$][0] + 1) + (modulo_num[$n-1$][2] + 1)

3. modulo_num[$n$][2]  

$n-2$ 자리의 수에서 소급하여 보자.  

(modulo_num[$n-2$][0] + 1) + (modulo_num[$n-2$][1] + 1) + (modulo_num[$n-2$][2] + 2)  

$n-1$ 자리의 수에서 소급하여 보자.  

(modulo_num[$n-1$][0] + 1) + (modulo_num[$n-1$][1] + 1)  

## 초기조건과 출력해야하는 결과

modulo_num[0][k] = 0 for all $k$  
modulo_num[1][k] = 0 for all $k$  
modulo_num[2][0] = 1, modulo_num[2][1] = 1, modulo_num[2][2] = 0  
그 이후부터는 이전의 정보를 이용하여 구하면 된다. 

우리는 15의 배수인 것을 찾아야 하므로 modulo_nums[N][0]을 출력하면 된다.  

## 시간복잡도 계산

이중 for 문을 통하여 dp table을 채울 수 있다.  
아마 프로그램을 짠다면 첫번째 for문은 문자의 자리수 만큼 돌 것이고, 두번째 for 문에서는 나머지의 개수만큼 돌릴 것이다. 즉, 시간복잡도는 $O(N)$의 아주 이쁜 linear time complexity를 가지게 된다.  

설마 문제가 constant time에 해결하라는 노양심 문제는 아닐테니 될거 이 정도 시간 복잡도라면 겁나 빠르게 돌아가는 프로그램인게 분명하다. 만약 1초에 $10^8$번의 계산이 가능하다고 가정하면 1초 안에 풀 수 있는 문제가 분명하다.  

## 예제 입력을 통한 확인

### 소스코드

```cpp
#include <iostream>

using namespace std;
using ll = long long;

enum
{
    DIVIDER = 1000000007,
    MAX_LENGTH = 1516,
    REMAINDER_NUM = 3
};

ll modulo_num[MAX_LENGTH][REMAINDER_NUM] = { 0, };

int main(void)
{
    size_t N;
    cin >> N;
    for(size_t k = 0 ; k < REMAINDER_NUM ; k++)
    {
        modulo_num[0][k] = 0;
        modulo_num[1][k] = 0;
    }

    modulo_num[2][0] = 1, modulo_num[2][1] = 1, modulo_num[2][2] = 0;

    for(size_t current_length = 3 ; current_length <= N ; current_length++)
    {
        for(size_t remainder_type = 0 ; remainder_type < REMAINDER_NUM ; remainder_type++)
        {
            if(remainder_type == 0)
            {
                modulo_num[current_length][0]
                    =
                    (
                        (modulo_num[current_length - 2][0] + 2) +
                        (modulo_num[current_length - 2][1] + 1) + 
                        (modulo_num[current_length - 2][2] + 1) + 
                        (modulo_num[current_length - 1][1] + 1) + 
                        (modulo_num[current_length - 1][2] + 1)
                    ) % DIVIDER;
            }
            else if(remainder_type == 1)
            {
                modulo_num[current_length][1]
                    =
                    (
                        (modulo_num[current_length - 2][0] + 1) +
                        (modulo_num[current_length - 2][1] + 2) + 
                        (modulo_num[current_length - 2][2] + 1) + 
                        (modulo_num[current_length - 1][0] + 1) + 
                        (modulo_num[current_length - 1][2] + 1)
                    ) % DIVIDER;
            }
            else
            {
                modulo_num[current_length][2]
                    =
                    (
                        (modulo_num[current_length - 2][0] + 1) +
                        (modulo_num[current_length - 2][1] + 1) + 
                        (modulo_num[current_length - 2][2] + 2) +
                        (modulo_num[current_length - 1][0] + 1) +
                        (modulo_num[current_length - 1][1] + 1)
                    ) % DIVIDER;
            }
        }
    }
    cout << modulo_num[N][0];
    return 0;
}
```
이와 같이 코드를 짰다. 그런데 3을 입력했을 때 출력으로 1이 나와야 하는데, 7이 나온다. ~~야1발~~

## 왜 답이 잘못 나올까?

~~3일 때 내가 짠 알고리즘으로 생각해 보면 중복의 문제가 생긴다는 것을 알 수 있었다. 위의 관찰에서 구했던 것인데, $N = 3$인 경우에는 555로 15의 배수인 것이 유일한데, 이는 55에서 5를 추가한 것일수도 있고, 5에서 55를 추가한 것일 수도 있다. 그런데 나는 두 경우를 모두 생각해서 경우의 수를 계산했기 때문에 당연하게도 더 큰 결과값이 나오게 된 것이다.~~  

또 하나 크게 잘못 생각 한 것이 있다. 만약에 55에서 5를 추가해서 5로 갔다면 이것은 2자리인 숫자 중에 나머지가 1인 수의 개수에 어떤 수가 더하여 지지 않고 그대로 가야 할 것이다.  

관찰하는 과정에서 숫자가 늘어나면 더해야 한다는 편견 때문에 그냥 1을 더한 것이다. 이 점을 나중에 풀때도 반드시 기억해야겠다. 숫자가 반드시 더해지는 것은 아니라는 것을 기억하자!!!

오늘은 졸려서 여기까지 쓰고 다음 내용부터는 아침에 일어나서 써야겠다.
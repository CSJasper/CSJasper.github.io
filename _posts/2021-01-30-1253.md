---
title: 백준 1253 '좋다' 풀이 (미완성)
tags: 투포인터
key: 알고리즘
tags: 백준-1253
---
<center><img src="/image/isgood/isgood.png"></center>

# 문제 읽기

1. N개의 수가 주어진다.  

2. 좋은 수는 주어진 N개의 수 중 두 수의 합으로 나타낼 수 있는 수를 말한다.  

3. 수의 위치가 다르면 값이 같아도 다른 수이다.  

Naive 하게 풀어본다면 주어진 수를 하나 고정하고, 그 수를 제외한 나머지 수를 두개 골라 확인하면 된다. 3중 for 문을 이용하여 구할 수 있고 시간복잡도는 $O(N^{3})$이 된다.  

2000개의 숫자가 최대로 들어올 수 있고 대략 $2 \times 10^{9}$ 번의 계산을 해야 한다. 1초에 $10^{8}$ 번의 계산이 가능하다면, 주어진 제한시간 2초에는 $2 \time 10^{8}$번의 계산이 가능할 것이다. 즉 시간초과가 난다.  

다른 방법이 필요하다.  

# 관찰하자!

## 문제 다시 읽기

1. 입력으로 중복된 숫자가 나올 수도 있다.  

2. 입력은 반드시 정렬된 수일 필요가 없다.  

만약 정렬되어 있다면 가장 첫번째 수는 절대 좋은 수가 아니다. 왜냐하면 가장 작은 두 수의 합이 가장 작은 수 보다 크기 때문이다.  

즉, 정렬되어 있는 수열에 대해서는 두 번째 원소부터 '좋은 수'인지 확인하면 된다.  

## 투 포인터는 for문 두개를 1개로 줄여준다

정렬되어 있는 수열에 대해 어떤 수가 좋은 수인지 알아 내는 방법을 left, right의 투 포인터를 이용해 구하는 방법을 생각해 보도록 하자.  

우리는 어떤 수 $a$가 좋은 수인지 알고 싶다. left가 가리키는 숫자와 right가 가리키는 숫자의 합은 세 가지 경우 중 하나이다.  

주어진 $N$ 개의 수열을 nums[] 라고 한다면,  

1. nums[left] + nums[right] = $a$  

만약에 이 경우라면 좋은 수의 개수를 저장하는 변수(여기서는 cnt라 하자) cnt에 + 1 을 해 주면 된다.  

2. nums[left] + nums[right] < $a$  

만약 구하고자 하는게 더 작다면
3. nums[left] + nums[right] > $a$  
